"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Reclaim = void 0;
const crypto_sdk_1 = require("@reclaimprotocol/crypto-sdk");
const ethers_1 = require("ethers");
const pino_1 = __importDefault(require("pino"));
const utils_1 = require("../utils");
const CustomProvider_1 = require("./CustomProvider");
const HttpsProvider_1 = require("./HttpsProvider");
const Template_1 = __importDefault(require("./Template"));
const logger = (0, pino_1.default)();
/** Reclaim class */
class Reclaim {
    constructor() {
        /**
         * function to request proofs from Reclaim
         * @param request Proof request
         * @returns {TemplateInstance} Template instance
         */
        this.requestProofs = (request) => {
            const template = {
                id: (0, utils_1.generateUuid)(),
                name: request.title,
                callbackUrl: (0, utils_1.generateCallbackUrl)(request.baseCallbackUrl, request.callbackId),
                claims: request.requestedProofs.map((requestedProof) => {
                    return {
                        templateClaimId: (0, utils_1.generateUuid)(),
                        // eslint-disable-next-line @typescript-eslint/no-explicit-any
                        provider: requestedProof.params.provider,
                        payload: requestedProof.params.payload,
                    };
                })
            };
            const regexes = request.requestedProofs.map((requestedProof) => {
                return requestedProof.regex;
            });
            return new Template_1.default(template, regexes);
        };
        /**
         * function to verify the witness signatures
         * @param proofs proofs returned by the callback URL
         * @returns {Promise<boolean>} boolean value denotes if the verification was successful or failed
         */
        this.verifyCorrectnessOfProofs = async (proofs) => {
            let result = false;
            for (const proof of proofs) {
                // fetch on chain witness address for the claim
                const witnesses = await (0, utils_1.getClaimWitnessOnChain)(proof.chainId, parseInt(proof.onChainClaimId));
                // if no witnesses are present: return false
                if (!witnesses.length) {
                    logger.error('No witnesses found on chain');
                    return result;
                }
                const claim = {
                    id: parseInt(proof.onChainClaimId),
                    ownerPublicKey: Buffer.from(proof.ownerPublicKey, 'hex'),
                    provider: proof.provider,
                    timestampS: parseInt(proof.timestampS),
                    witnessAddresses: witnesses,
                    redactedParameters: proof.redactedParameters
                };
                const decryptedProof = {
                    parameters: JSON.stringify(proof.parameters),
                    signatures: proof.signatures.map(signature => {
                        return ethers_1.utils.arrayify(signature);
                    })
                };
                // fetch on chain claim data from the request id
                const claimData = await (0, utils_1.getOnChainClaimDataFromRequestId)(proof.chainId, proof.onChainClaimId);
                const onChainInfoHash = claimData.infoHash;
                const calculatedInfoHash = (0, crypto_sdk_1.hashClaimInfo)({ parameters: decryptedProof.parameters, provider: proof.provider, context: '' }); //TODO: pass context from the app
                // if the info hash is not same: return false
                if (onChainInfoHash.toLowerCase() !== calculatedInfoHash.toLowerCase()) {
                    logger.error('Info hash mismatch');
                    return result;
                }
                try {
                    // verify the witness signature
                    result = (0, crypto_sdk_1.verifyWitnessSignature)(claim, decryptedProof);
                    logger.info(`isCorrectProof: ${result}`);
                }
                catch (error) {
                    // if the witness signature is not valid: return false
                    logger.error(`${error}`);
                    result = false;
                }
            }
            return result;
        };
        /**
         * function to get the onChainClaimIds from the proofs
         * @param proofs
         * @returns {string}
         */
        this.getOnChainClaimIdsFromProofs = (proofs) => {
            const onChainClaimIdArray = [];
            for (const proof of proofs) {
                const onChainClaimId = proof.onChainClaimId;
                onChainClaimIdArray.push(onChainClaimId);
            }
            return onChainClaimIdArray;
        };
    }
    get HttpsProvider() {
        return HttpsProvider_1.HttpsProvider;
    }
    get CustomProvider() {
        return CustomProvider_1.CustomProvider;
    }
}
exports.Reclaim = Reclaim;

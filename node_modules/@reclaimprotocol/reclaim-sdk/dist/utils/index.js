"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.isProof = exports.extractParameterValuesFromRegex = exports.getCallbackIdFromUrl = exports.generateCallbackUrl = exports.decodeBase64 = exports.encodeBase64 = exports.getProofsFromRequestBody = exports.getContract = exports.getClaimWitnessOnChain = exports.getOnChainClaimDataFromRequestId = exports.generateUuid = void 0;
const ethers_1 = require("ethers");
const uuid_1 = require("uuid");
const config_json_1 = __importDefault(require("../utils/contracts/config.json"));
const types_1 = require("../utils/contracts/types");
function generateUuid() {
    return (0, uuid_1.v4)();
}
exports.generateUuid = generateUuid;
const existingContractsMap = {};
async function getOnChainClaimDataFromRequestId(chainId, claimId) {
    const contract = getContract(chainId);
    const pendingCreateData = await contract.claimCreations(claimId);
    if (!(pendingCreateData === null || pendingCreateData === void 0 ? void 0 : pendingCreateData.claim.claimId)) {
        throw new Error(`Invalid request ID: ${claimId}`);
    }
    const claim = pendingCreateData.claim;
    return {
        infoHash: claim.infoHash,
        owner: claim.owner.toLowerCase(),
        timestampS: claim.timestampS,
        claimId: claim.claimId
    };
}
exports.getOnChainClaimDataFromRequestId = getOnChainClaimDataFromRequestId;
async function getClaimWitnessOnChain(chainId, claimId) {
    const contract = getContract(chainId);
    const witnesses = await contract.getClaimWitnesses(claimId);
    return witnesses;
}
exports.getClaimWitnessOnChain = getClaimWitnessOnChain;
function getContract(chainId) {
    const chainKey = `0x${chainId.toString(16)}`;
    if (!existingContractsMap[chainKey]) {
        const contractData = config_json_1.default[chainKey];
        if (!contractData) {
            throw new Error(`Unsupported chain: "${chainKey}"`);
        }
        const rpcProvider = new ethers_1.ethers.providers.JsonRpcProvider(contractData.rpcUrl);
        existingContractsMap[chainKey] = types_1.Reclaim__factory.connect(contractData.address, rpcProvider);
    }
    return existingContractsMap[chainKey];
}
exports.getContract = getContract;
function getProofsFromRequestBody(requestBody) {
    const proofs = JSON.parse(decodeURIComponent(requestBody)).proofs;
    return proofs;
}
exports.getProofsFromRequestBody = getProofsFromRequestBody;
function isValidUrl(url) {
    try {
        new URL(url);
        return true;
    }
    catch (err) {
        return false;
    }
}
function encodeBase64(str) {
    return Buffer.from(JSON.stringify(str)).toString('base64');
}
exports.encodeBase64 = encodeBase64;
function decodeBase64(str) {
    return JSON.parse(Buffer.from(str, 'base64').toString('utf-8'));
}
exports.decodeBase64 = decodeBase64;
function generateCallbackUrl(baseUrl, callbackId) {
    // check if valid url
    if (!isValidUrl(baseUrl)) {
        throw new Error('Invalid URL');
    }
    const id = callbackId ? callbackId : generateUuid();
    //check for trailing slash
    if (baseUrl.endsWith('/')) {
        // remove trailing slash
        baseUrl = baseUrl.slice(0, -1);
    }
    return `${baseUrl}?id=${id}`;
}
exports.generateCallbackUrl = generateCallbackUrl;
function getCallbackIdFromUrl(_url) {
    // check if valid url
    if (!isValidUrl(_url)) {
        throw new Error('Invalid URL');
    }
    const url = new URL(_url);
    const urlParams = new URLSearchParams(url.search);
    const callbackId = urlParams.get('id');
    if (!callbackId) {
        throw new Error('Callback Id not found in URL');
    }
    else {
        return callbackId;
    }
}
exports.getCallbackIdFromUrl = getCallbackIdFromUrl;
function extractParameterValuesFromRegex(expectedProofsInCallback, proofs) {
    // parse expectedProofsInCallback
    const selectionRegexes = decodeBase64(expectedProofsInCallback);
    // check if correct number of response selections are present
    if (selectionRegexes.length !== proofs.length) {
        throw new Error('Invalid number of proofs');
    }
    // create object to store parameter values
    const parameterObj = {};
    proofs.forEach((proof, index) => {
        // console.log(proof)
        if (proof.parameters.responseSelections) {
            // TODO: support multiple response selections inside each proof
            // get first response selection since we only support one for now
            const proofResponseSelection = proof.parameters.responseSelections[0];
            if (proofResponseSelection.responseMatch) {
                // get regex string from response selection
                const responseMatchRegex = selectionRegexes[index];
                const parameterKeys = [];
                // replace all {{parameterName}} with (.*?)
                const regexString = responseMatchRegex.replace(/{{(.*?)}}/g, (_, parameterName) => {
                    parameterKeys.push(parameterName);
                    return '(.*?)';
                });
                // create regex from string
                const regex = new RegExp(regexString, 'g');
                const regexStringWithValues = proofResponseSelection.responseMatch;
                const regexValues = regex.exec(regexStringWithValues);
                if (regexValues !== null) {
                    for (let i = 0; i < parameterKeys.length; i++) {
                        const parameterKey = parameterKeys[i];
                        const parameterValue = regexValues[i + 1];
                        parameterObj[parameterKey] = parameterValue;
                    }
                }
            }
        }
    });
    return parameterObj;
}
exports.extractParameterValuesFromRegex = extractParameterValuesFromRegex;
// type guard for proof
function isProof(obj) {
    return (obj.chainId !== undefined &&
        obj.parameters !== undefined &&
        obj.onChainClaimId !== undefined &&
        obj.ownerPublicKey !== undefined &&
        obj.signatures !== undefined &&
        obj.timestampS !== undefined &&
        obj.provider !== undefined &&
        obj.witnessAddresses !== undefined &&
        obj.templateClaimId !== undefined);
}
exports.isProof = isProof;

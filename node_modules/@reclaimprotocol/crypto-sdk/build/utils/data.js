"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.verifyWitnessSignature = exports.verifyEncryptedClaims = exports.decryptData = exports.encryptData = exports.encryptClaimProof = void 0;
var crypto_1 = require("crypto");
var ethers_1 = require("ethers");
var utils_1 = require("ethers/lib/utils");
var hkdf = require("futoin-hkdf");
var buffer_json_1 = require("./buffer-json");
var redactions_1 = require("./redactions");
var sign_data_1 = require("./sign-data");
var signatures_1 = require("./signatures");
var AUTH_TAG_LENGTH = 16;
/**
 * Encrypts data using recipient's public key and sender's private key.
 * @param publicKey - Recipient public key in raw (un-hexed) form.
 * @param privateKey - Sender's private key in raw (un-hexed) form.
 * @param data - claim proof to encrypt
 */
function encryptClaimProof(publicKey, privateKey, data) {
    var serialised = Buffer.from(JSON.stringify(data, buffer_json_1.BufferJSON.replacer));
    return encryptData(publicKey, privateKey, serialised);
}
exports.encryptClaimProof = encryptClaimProof;
/**
 * Encrypts data using recipient's public key and sender's private key.
 * @param {Uint8Array} publicKey - Recipient public key in raw (un-hexed) form.
 * @param {Uint8Array} privateKey - Sender's private key in raw (un-hexed) form.
 * @param {Uint8Array} data - serialized data to encrypt
 */
function encryptData(publicKey, privateKey, data) {
    var _a = getKeyAndSalt(publicKey, privateKey), key = _a.key, salt = _a.salt;
    var cipher = (0, crypto_1.createCipheriv)('aes-256-gcm', key, salt, { authTagLength: AUTH_TAG_LENGTH });
    return Buffer.concat([
        cipher.update(data),
        cipher.final(),
        cipher.getAuthTag()
    ]);
}
exports.encryptData = encryptData;
/**
 * Decrypts data using sender's public key and recipient's private key.
 * @param {Uint8Array} privateKey - Recipient's private key in raw (un-hexed) form.
 * @param {Uint8Array} publicKey -Sender's public key in raw (un-hexed) form.
 * @param {Uint8Array} ciphertext - encrypted data
 */
/**
 * Decrypts data using sender's public key and recipient's private key.
 * @param {Uint8Array} privateKey - Recipient's private key in raw (un-hexed) form.
 * @param {Uint8Array} publicKey -Sender's public key in raw (un-hexed) form.
 * @param {Uint8Array} ciphertext - encrypted data
 */
function decryptData(privateKey, publicKey, ciphertext) {
    var _a = getKeyAndSalt(publicKey, privateKey), key = _a.key, salt = _a.salt;
    var decipher = (0, crypto_1.createDecipheriv)('aes-256-gcm', key, salt, { authTagLength: AUTH_TAG_LENGTH });
    decipher.setAuthTag(ciphertext.subarray(ciphertext.length - AUTH_TAG_LENGTH));
    ciphertext = ciphertext.subarray(0, ciphertext.length - AUTH_TAG_LENGTH);
    return Buffer.concat([
        decipher.update(ciphertext),
        decipher.final()
    ]);
}
exports.decryptData = decryptData;
/**
 * Call to verify that the claims are proven by the encrypted proofs
 * @param claims the claims to verify
 * @param encryptedProofs encrypted proofs of the claims
 * @param privateKey private part of the communication key, must have been used
 * to encrypt the "encryptedProofs"
 */
function verifyEncryptedClaims(claims, encryptedProofs, privateKey) {
    var revealedClaims = {};
    // claims we have not found a proof for
    var claimsMissing = new Set(claims.map(function (c) { return c.id; }));
    var _loop_1 = function (id, enc) {
        var claim = claims.find(function (c) { return c.id === id; });
        if (!claim) {
            throw new Error('Claim not found');
        }
        // 1. check the data decrypts successfully
        var decryped = decryptData(privateKey, claim.ownerPublicKey, enc);
        // 2. check the data is valid JSON
        var proof = JSON.parse(decryped.toString(), buffer_json_1.BufferJSON.reviver);
        // 3. check the claim parameters contained original link
        // match the ones decrypted
        if (!(0, redactions_1.isRedactionCongruent)(claim.redactedParameters, proof.parameters)) {
            throw new Error("Claim parameters do not match for \"".concat(id, "\", redacted=\"").concat(claim.redactedParameters, "\", decrypted=\"").concat(proof.parameters, "\""));
        }
        verifyWitnessSignature(claim, proof);
        claimsMissing.delete(id);
        revealedClaims[id] = proof;
    };
    // go through all encrypted proofs and decrypt them
    // check if the decrypted proof matches the claim
    for (var _i = 0, encryptedProofs_1 = encryptedProofs; _i < encryptedProofs_1.length; _i++) {
        var _a = encryptedProofs_1[_i], id = _a.id, enc = _a.enc;
        _loop_1(id, enc);
    }
    // 7. if there are any claims left, that did not have a proof
    // throw an error, because we expected all claims to be proven
    if (claimsMissing.size) {
        var missing = claims.map(function (c) { return c.id; }).join(', ');
        throw new Error("Not all claims were proven: ".concat(missing));
    }
    return revealedClaims;
}
exports.verifyEncryptedClaims = verifyEncryptedClaims;
/**
 * Step 4 of verifyEncryptedClaims()
 * Call to verify if the claim has witness signature
 * @param claim the claim to check for witness signature
 * @param proof decrypted proof
 */
function verifyWitnessSignature(claim, proof) {
    // 4. go through all signatures
    // and check that they are valid
    var dataStr = (0, sign_data_1.createSignDataForClaim)({
        provider: claim.provider,
        parameters: proof.parameters,
        owner: signatures_1.signatures.getAddress(claim.ownerPublicKey),
        timestampS: claim.timestampS,
        claimId: claim.id,
        context: ''
    });
    // set of witnesses whose signatures we've not seen
    var witnesses = new Set(claim.witnessAddresses);
    var signatureAddresses = new Set();
    for (var _i = 0, _a = proof.signatures; _i < _a.length; _i++) {
        var signature = _a[_i];
        var signer = ethers_1.utils.verifyMessage(dataStr, signature).toLowerCase();
        signatureAddresses.add(signer);
    }
    // check that each witness signed the claim
    witnesses.forEach(function (_witness) {
        var witness = _witness.toLowerCase();
        if (signatureAddresses.has(witness)) {
            signatureAddresses.delete(witness);
        }
        else {
            throw new Error("Could not find signature for witness: ".concat(witness));
        }
    });
    // check for extra signatures
    if (signatureAddresses.size > 0) {
        throw new Error("Claim signed by more witnesses than expected");
    }
    else {
        return true;
    }
}
exports.verifyWitnessSignature = verifyWitnessSignature;
function getKeyAndSalt(publicKey, privateKey) {
    var sharedSecret = Buffer.from(ethers_1.utils.arrayify(new utils_1.SigningKey(privateKey).computeSharedSecret(publicKey)));
    var key = hkdf(sharedSecret, 32, { salt: 'reclaim-key' });
    var salt = hkdf(sharedSecret, 12, { salt: 'reclaim-salt' });
    return { key: key, salt: salt };
}
//# sourceMappingURL=data.js.map